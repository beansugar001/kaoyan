# 图的定义
图G由定点集V和边集E组成,记为G = (V, E)
其中,V(G)表示图中定点的优先非空集;E(G)表示图G中定点之间的关系(边)集合.若$V = {v_1, v_2, .. v_n}$,则用$|V|$表示图G中定点的个数,也称**图的阶**;$E = {(u, v) | U∈V, v∈V}$,用$|E|$表示图G中边的条数
**图不可以是空,即V一定是非空集**
无向边记为(v,w) = (w,v),其中v,w为顶点,**互为邻接点**.边(v,w)依附于顶点w,v
有向边(弧)的优先集合时,则图G为**有向图**.弧是顶点的有序对,记为<v,w>,v**为弧头**,w为**弧尾**
对于无向图:顶点v的度是指依附于该顶点的边的条数,记为TD(V)
对于有向图:入度是以定点v为终点的有向边的数目,记为ID(v);
出度是以顶点v为起点的有向边的数目,记为OD(v)
顶点v的度=入度+出度
对于n个顶点的无向图,若G是连通图,则最少有n-1条 边;若g是非连通图,则最多有可能有$c_{n-1}^2$条边
强连通图:任何一堆顶点都是强连通的
对于n个顶点的有向图g,若为强连通图,则最少有n条边(形成回路的情况)
生成子图:包含原图中的所有顶点
强连通图:图中的任意一点都是强连通的(从a->b,b->a都有路径称为强连通)
连通分量:**极大**连通子图
生成树:包含图中全部顶点的一个极小连通子图(边尽可能少,但要保持连通)
若生成树顶点为n则有n-1条边.
无向完全图:任意两个顶点间都存在边.$|E|∈[0, n(n-1)/2]$
有向完全图:任意两个顶点之间都存在方向相反的两条弧.$|E|∈[0,n9(n-1)]$
n个顶点的图,若|E|>n-1,则一定有回路
有向树:一个顶点的入度为0,其余顶点的入度均为1的有向图.
### 常见考点
对于n个顶点的无向图G
- 所有顶点的度之和= 2|E|
- 若g是连通图,则最少有n-1条边,若|E|>n-1,则一定有回路
- 若g是非连通图,则最多有可能有$C_{n-1}^2$条边
- 完全无向图共有$C_{n}^2$  
对于n个顶点的有向图g:
- 所有顶点的出度之和=入度之和=|E|
- 所有顶点的度之和=2|E|
- 若g是强连通图,则最少有n条边
- 有向完全图共有$2C_n^2$条边
- 若一个顶点只有入度或出度,则该顶点一定构成一个连通分量.
# 图的存储
### 邻接矩阵
```c++
#define MaxVertexNum 100
typedef char VertexType;
typedef int EdgeType;
typedef struct{
    VertexType vex[MaxVertexNum];//顶点表
    EdgeType edge[MaxVertexNum][MaxVertexNum];//邻接矩阵边表
    int vexnum, arcnum;//图当前的顶点数和边数
}
```
**时间复杂度**:$O(|V|^2)$
设图的邻接矩阵为A(矩阵元素为0/1),则$A^n$元素$A^n[i][j]$等于由顶点i到j的长度为n的数目
### 邻接表
```c++
#define MaxVertexNum 100
typedef struct ArcNode{
    ing adjvex;//该弧所指向的顶点的位置
    struct ArcNode *nextarc;//指向下一条弧的指针
    //InfoType info;//网的边权值
}ArcNode;
typedef struct VNode{//顶点表结点
    VertexType data;//顶点信息
    ArcNode *firstarc//指向第一条依附该顶点的弧的指针
}VNode, AdjList[MaxVertexNum];
typedef struct{
    AdjList vertices;//邻接表
    int vexnum, arcnum;//图的顶点数和弧数
}ALGraph;

```
**时间复杂度**:无向图$O(|V| + 2|E|)$有向图$O(|V| + |E|)$
### 十字链表
只能有向图
**时间复杂度**:$O(|V| + |E|)$
### 邻接多重表
只能无向图
**时间复杂度**:$O(|V| + |E|)$