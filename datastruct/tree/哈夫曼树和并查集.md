# 哈夫曼树
### 定义
- 树中结点的数值成为结点的**权**
- 从树的根到一个结点的路径长度该结点上权值的乘积,称为该结点的**带权路径的长度**
- 树中所有叶节点的带权路径长度之和称为该**树的带权路径长度**,记为 
        $WPL = \sum_{i=1}^n w_il_i$ 
  其中$w_i$是第i个叶结点所带的权值,$l_i$是该叶结点到根节点的路径长度
- 在含有n个带权叶结点的二叉树中,带权路径最小的二叉树称为哈夫曼树(最优二叉树)
### 哈夫曼树的构造
给定n个权值分别为w_1,w_2...w_n的节点
1. 将这n个结点分别作为n棵仅含一个结点的二叉树,构成森林F
2. 构造一个新节点,从F中选取两课根结点权值最小的树作为新的结点的左右子树,并且将新结点的权值置为左右子树根结点的权值之和.
3. 从F中删除刚才选出的两棵树,同时将新得到的树加入到F中.
4. 重复步骤2,3直到F中只剩下一棵树为止.
### 哈夫曼树的性质
1. 每个初始结点最终都成为叶结点,且权值越小的结点到根结点的路径长度越大.
2. 构造过程中新建了$n-1$个双分支结点,因此哈夫曼树的结点总数为$2n-1$(是奇数).
3. 每次构造都选择2棵树作为新结点的孩子,因此哈夫曼树中不存在度为1的结点.
### 哈夫曼编码
哈夫曼编码的加权平均长度为:$WSL/sum(w_i)$,其中WSL为树的带权路径长度,wi为叶结点的值
# 并查集
### 概念
一种简单的集合表示,总的来说是森林的集合.
可分为三种基本操作
1. 查找
2. 合并
3. 初始化
### 存储结构
通常用**双亲表示**作为并查集的存储结构,每个子集以一棵树表示.所有表示子集合的树,构成表示全集合的**森林**,存放在双亲表示的数组内.通常用数组元素的下标代表元素名,用根结点的下标代表子集合名,根结点的双亲域为负数(设置为该子集合元素数量的相反数)
### 实现
```c++
//初始化
#define SIZE 100
int UFSets[SIZE];

void Initial(int S[]){
    for(int i = 0; i < SIZE; i ++) {
        S[i] = -1;
    }
}
//find操作
int find(int S[], int x) {
    while(S[x] >= 0)
        x = S[x];
    return x;
}
//union操作
//先找到连个子树的根,再令一颗子树的根指向另一棵子集树的根
void union(int s[], int root1, int root2) {
    if(roo1 == root2) return;
    S[root2] = root1;
}
```
此时find和union时间复杂度为O(n)和O(1)
### 并查集实现的优化
在做union操作之前,首先判别子集中的成员数量,然后令成员少的根指向成员多的根,即把小树合并到大树.
```c++
void union(int S[], int root1, int root2) {
    if(root1 == root2) return;
    if(S[root2] > S[root1]) {
        S[root1] += S[root2];
    }else{
        S[root2] += S[root1];
        S[root1] = root2;
    }
}
```
这种方法构造得到的集合树,其深度不超$过[log_2 n] + 1$