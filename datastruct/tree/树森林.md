# 树的存储
### 双亲表示法
采用连续空间来存储每个节点,同时在每个节点上增设一个伪指针指向其双亲结点在数组中的位置
根节点伪指针指向-1
```c
typedef struct{
    ElemType data;//结点
    int parent;//双亲结点指针
}PTNode;
typedef struct{
    PTNode nodes[MAX_TREE_SIZE];
    int n;
}
```
**优点**:找父节点很方便
**缺点**:找孩子不方便,只能从头到尾遍历整个数组
### 孩子表示法
将每个节点的孩子视为一个线性表,且以单链表作为存储结构,则n个节点就有n个孩子链表.而n个头指针又组成一个线性表
```c
struct CTNode{
    int childl
    struct CTNode *next;//下一个孩子节点
}
typedef struct{
    ElemType data;
    struct CTNode *firstChild;//第一个孩子节点
}CTBox;
typedef struct{
    CTBox nodes[MAX_TREE_SIZE];
    int n,r;//节点数 根的位置
}
```
**优点**:找孩子节点很方便
**缺点**:找父节点不方便,只能从头到尾遍历整个数组
### 孩子兄弟表示法
```c
typedef struct CSNode{
    ElemType data;
    struct CSNode *firstChild, *nextsibling;//第一个孩子节点和兄弟结点
}CSNode, *CSTree;
```

# 树森林与二叉树的转换
### 树->二叉树
注意:现在二叉树中,画一个根节点,再按树的层序遍历依次处理每个节点
1. 先画出根节点
1. 如果有兄弟节点,连到右孩子上
2. 如果有孩子,按层序遍历穿成一串,并且连接到左孩子上

树转换为二叉树时,二叉树中无右孩子结点的个数=分支结点树+1
### 森林->二叉树
注意:先把第一层的根节点从左到右串起来,再层序处理每个点
1. 如果有孩子,按层序遍历穿成一串,并且连接到左孩子上
### 二叉树->树
注意:先画根节点,再按树的层序遍历依次处理每个节点
1. 看是否有左孩子,若有,将左孩子和"一整串右指针冰糖葫芦"拆下来,按顺序改在当前节点的下方

### 二叉树->森林
注意:先把二叉树的根节点和"一整串右指针冰糖葫芦"拆下来,作为多棵树的根节点.再按层序恢复
# 遍历
### 树的遍历
类似二叉树
### 森林的遍历
先序遍历:若非空,先访问第一棵树中的根节点,先序遍历第一棵树中的根节点的子树森林,先序遍历除去第一棵树之后剩余的树构成的森林